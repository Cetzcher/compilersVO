%{
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#define STATE_TYPE void*
#include "scope.h"
#include "instructions.h"

#define L(p)   	((p)->children[0])
#define R(p)    ((p)->children[1])
#define UNPACK_3 bnode, bnode->children[0], bnode->children[1] 
#define UNPACK_2 bnode, bnode->children[0]

%}

%start expr
%term      OP_NOP = 0 OP_PLUS = 1 OP_MINUS = 2 OP_NUM = 3 OP_VAR = 4 OP_ZERO = 5 OP_ONE = 6 OP_MULT = 7 OP_HASH = 8 OP_LTEQ = 9 OP_AND = 10 OP_NOT = 11
%%

expr: const                     # 0 #   printf("\tMOVQ $%d, %%rax\n", bnode->value);
expr: reg                       # 0 #   finalize(bnode);

const: OP_NUM                   # 0 # 
const: OP_PLUS(const, const)    # 0 #   bnode->value = L(bnode)->value + R(bnode)->value; 
const: OP_MINUS(const)          # 0 #   bnode->value = -(L(bnode)->value);
const: OP_MULT(const, const)    # 0 #   bnode->value = L(bnode)->value * R(bnode)->value;
const: OP_AND(const, const)     # 0 #   bnode->value = L(bnode)->value & R(bnode)->value;
const: OP_NOT(const)            # 0 #   bnode->value = ~(L(bnode)->value);
const: OP_LTEQ(const, const)    # 0 #   bnode->value = (L(bnode)->value <= R(bnode)->value) ? -1 : 0; 
const: OP_HASH(const, const)    # 0 #   bnode->value = (L(bnode)->value != R(bnode)->value) ? -1 : 0;


reg: OP_PLUS(reg, reg)    # 2 # add(UNPACK_3);
reg: OP_PLUS(reg, const)  # 1 # addc(UNPACK_3);
reg: OP_PLUS(const, reg)  # 1 # addcr(UNPACK_3);
reg: OP_MULT(reg, reg)    # 2 # mul(UNPACK_3);
reg: OP_AND(reg, reg)     # 2 # and(UNPACK_3);
reg: OP_MINUS(reg)        # 2 # minus(UNPACK_2);
reg: OP_NOT(reg)          # 2 # not(UNPACK_2);
reg: OP_VAR               # 0 # 

%%


